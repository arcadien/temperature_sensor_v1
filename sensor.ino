/*****************************************************************************
* Model: sensor.qm
* File:  ./sensor.ino
*
* This code has been generated by QM tool (see state-machine.com/qm).
* DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
*
* This program is open source software: you can redistribute it and/or
* modify it under the terms of the GNU General Public License as published
* by the Free Software Foundation.
*
* This program is distributed in the hope that it will be useful, but
* WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
* or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
* for more details.
*****************************************************************************/
/*${.::sensor.ino} .........................................................*/
#include "qpn.h"        // QP-nano framework
#include "Arduino.h"    // Arduino API
#include "oregon.h" // 433Mhz transmission library

#include <avr/sleep.h>
#include <avr/wdt.h>

Q_DEFINE_THIS_MODULE("sensor")

// define to println() many information
//#define TRACE 1

enum {
    BSP_TICKS_PER_SEC = 100,  // number of system clock ticks in one second
    LED_PIN           = 3,  // the pin number of the on-board LED
    PERIPH_VCC_PIN    = 10,  // the pin number which activates the vcc rail for peripherals (emitter, sensors)
    SENSOR_COUNT      = 1,   // How many sensors do we have, ie how many data row to send
};


// ------------

// some constant for temperature sensor
#define ANALOG_TEMP_SENSOR_PIN A0
const uint8_t TEMP_SAMPLE_COUNT = 16; // 2^4, allow division with bitshift
// ratio to apply to the raw analog measurement from ADC on LM38

//#define TEMPERATURE_RATIO   1.087 / 1023.0 * 100.0

// see https://playground.arduino.cc/Main/LM35HigherResolution
#define AREF 1.087
#define TEMPERATURE_RATIO   10 / (AREF / 1024.0 * 1000)

// constants for 433Mhz emitter
#define TX_PIN  5 //pin where your transmitter is connected

uint8_t OREGON_TYPE[] = {0x1A,0x2D}; // inside temp
#define COMMAND_REPEAT_COUNT 5
#define OREGON_ID 0xBC
Oregon oregon(LED_PIN, TX_PIN, COMMAND_REPEAT_COUNT);
Oregon::Message message;

// emit each 5 minutes (how many 8sec watchdog wakeups)
const uint8_t SLEEP_DELAY_SECOND = (uint8_t)((5*60) / 8);
volatile uint8_t _sleepDelayCounter = SLEEP_DELAY_SECOND;



//============================================================================
enum SensorSignals {
    SEND_SIG = Q_USER_SIG,
    EMISSION_FINISHED_SIG,
    SENSE_SIG,

};


#if ((QP_VERSION < 591) || (QP_VERSION != ((QP_RELEASE^4294967295U) % 0x3E8)))
#error qpn version 5.9.1 or higher required
#endif

/*${AOs::Sensor} ...........................................................*/
typedef struct Sensor {
/* protected: */
    QActive super;

/* public: */
    Oregon::Message m_Message;
} Sensor;

/* protected: */
static QState Sensor_initial(Sensor * const me);
static QState Sensor_Active(Sensor * const me);
static QState Sensor_Sensing(Sensor * const me);
static QState Sensor_Sending(Sensor * const me);
static QState Sensor_Idle(Sensor * const me);

/*${AOs::Sensor} ...........................................................*/
/*${AOs::Sensor::SM} .......................................................*/
static QState Sensor_initial(Sensor * const me) {
    /* ${AOs::Sensor::SM::initial} */
    return Q_TRAN(&Sensor_Active);
}
/*${AOs::Sensor::SM::Active} ...............................................*/
static QState Sensor_Active(Sensor * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /* ${AOs::Sensor::SM::Active} */
        case Q_ENTRY_SIG: {
            #ifdef TRACE
              Serial.println("Enter Active");
            #endif

            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::Sensor::SM::Active} */
        case Q_EXIT_SIG: {
            #ifdef TRACE
                Serial.println("Exit Active");
            #endif
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::Sensor::SM::Active::initial} */
        case Q_INIT_SIG: {
            status_ = Q_TRAN(&Sensor_Sensing);
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
/*${AOs::Sensor::SM::Active::Sensing} ......................................*/
static QState Sensor_Sensing(Sensor * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /* ${AOs::Sensor::SM::Active::Sensing} */
        case Q_ENTRY_SIG: {
            #ifdef TRACE
              Serial.println(F("Enter Sensing"));
            #endif

            digitalWrite(PERIPH_VCC_PIN, HIGH);
            analogReference(INTERNAL);

            // http://www.ti.com/lit/ds/symlink/lm35.pdf p.12
            // (startup response)
            delay(30);

            uint16_t accumulator = 0;
            double analogVal = 0;

            // first read is usually false
            // make a blank read
            analogRead(ANALOG_TEMP_SENSOR_PIN);

            // message length is fixed
            for (uint8_t j = 0 ; j < TEMP_SAMPLE_COUNT ; ++j)
            {
              accumulator += analogRead(ANALOG_TEMP_SENSOR_PIN);
            }

            analogVal = (accumulator >> 4);

            // the value is adjusted with Aref value for each sensor module.
            analogVal = analogVal / TEMPERATURE_RATIO;

            me->m_Message.temperature = analogVal;

            Serial.print(me->m_Message.temperature);
            Serial.println(F(" Â°C"));

            QACTIVE_POST(&me->super, SEND_SIG, me->super.prio);
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::Sensor::SM::Active::Sensing} */
        case Q_EXIT_SIG: {
            #ifdef TRACE
                Serial.println(F("Exit TempSensing"));
            #endif

            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::Sensor::SM::Active::Sensing::SEND} */
        case SEND_SIG: {
            status_ = Q_TRAN(&Sensor_Sending);
            break;
        }
        default: {
            status_ = Q_SUPER(&Sensor_Active);
            break;
        }
    }
    return status_;
}
/*${AOs::Sensor::SM::Active::Sending} ......................................*/
static QState Sensor_Sending(Sensor * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /* ${AOs::Sensor::SM::Active::Sending} */
        case Q_ENTRY_SIG: {
            #ifdef TRACE
                Serial.println(F("Enter Sending"));
            #endif


            digitalWrite(LED_PIN, HIGH);

            oregon.Emit(OREGON_TYPE, Oregon::Channel::ONE, OREGON_ID, me->m_Message);

            digitalWrite(LED_PIN, LOW);

            digitalWrite(PERIPH_VCC_PIN, LOW);

            QACTIVE_POST(&me->super, EMISSION_FINISHED_SIG, me->super.prio);
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::Sensor::SM::Active::Sending} */
        case Q_EXIT_SIG: {
            #ifdef TRACE
                Serial.println(F("Exit Sending"));
            #endif
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::Sensor::SM::Active::Sending::EMISSION_FINISHED} */
        case EMISSION_FINISHED_SIG: {
            status_ = Q_TRAN(&Sensor_Idle);
            break;
        }
        default: {
            status_ = Q_SUPER(&Sensor_Active);
            break;
        }
    }
    return status_;
}
/*${AOs::Sensor::SM::Active::Idle} .........................................*/
static QState Sensor_Idle(Sensor * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /* ${AOs::Sensor::SM::Active::Idle} */
        case Q_ENTRY_SIG: {
            #ifdef TRACE
              Serial.println("Enter Idle");
            #endif
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::Sensor::SM::Active::Idle} */
        case Q_EXIT_SIG: {
            #ifdef TRACE
              Serial.println("Exit Idle");
            #endif
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::Sensor::SM::Active::Idle::SENSE} */
        case SENSE_SIG: {
            status_ = Q_TRAN(&Sensor_Sensing);
            break;
        }
        default: {
            status_ = Q_SUPER(&Sensor_Active);
            break;
        }
    }
    return status_;
}


Sensor AO_Sensor;

// QF_active[] array defines all active object control blocks ----------------
static QEvt l_sensorQSto[10]; // Event queue storage for Sensor

QActiveCB const Q_ROM QF_active[] = {
  { (QActive *)0,           (QEvt *)0,        0U                  },
  { (QActive *)&AO_Sensor,  l_sensorQSto,     Q_DIM(l_sensorQSto) }
};

void PrintSensorData()
{
    Serial.println(F("Temp sensor data: "));
    Serial.print("Temperature: ") ; Serial.println(AO_Sensor.m_Message.temperature);

}

void PrintInfo()
{
    Serial.print(F("QP-nano: "));
    Serial.println(F(QP_VERSION_STR));

    Serial.print(F("CPU Freq: "));
    Serial.print(F_CPU / 1000000);
    Serial.println("Mhz");

    Serial.print(F("Watchdog overflow count before emission: "));
    Serial.println(SLEEP_DELAY_SECOND);

    Serial.print(F("State machine ticks/s: "));
    Serial.println(BSP_TICKS_PER_SEC);

}

void setupWdt()
{
    cli();

    wdt_reset();

    MCUSR &= ~(1<<WDRF);

    // Start timed sequence
    WDTCSR |= (1<<WDCE) | (1<<WDE);

    WDTCSR = (1 << WDP3)|(1 << WDP0)| ( 1 << WDIE); // 8 sec, interrupts

    sei();
}

//............................................................................
void setup() {

    setupWdt();

    pinMode(13, OUTPUT);
    digitalWrite(13, LOW);

    pinMode(LED_PIN, OUTPUT);        // set the LED-PIN pin to output
    digitalWrite(LED_PIN, LOW);
    pinMode(PERIPH_VCC_PIN, OUTPUT);
    digitalWrite(PERIPH_VCC_PIN, 0);

    Serial.begin(57600);   // set the highest stanard baud rate of 115200 bps (mini pro uses x2)

    PrintInfo();

    // initialize the QF-nano framework
    QF_init(Q_DIM(QF_active));
    QActive_ctor(&AO_Sensor.super, Q_STATE_CAST(&Sensor_initial));

}

//
void loop() {
    QF_run(); // run the QP-nano application
}

ISR(WDT_vect)
{
    WDTCSR |= (1 << WDIE);
    if(_sleepDelayCounter == 0)
    {
        _sleepDelayCounter = SLEEP_DELAY_SECOND;
        QACTIVE_POST_ISR((QMActive *)&AO_Sensor, SENSE_SIG, 0U);
    }
    else
    {
        --_sleepDelayCounter;
    }
}

ISR(TIMER2_COMPA_vect) {
    if (Serial.available() > 0) {
        switch (Serial.read()) { // read the incoming byte
            case 'p':
            case 'P':
            {
               PrintInfo();
               break;
            }
            case 'd':
            case 'D':
            {
               PrintSensorData();
               break;
            }
       }
    }

    QF_tickXISR(0);

}

//============================================================================

// QF callbacks...
void QF_onStartup(void) {

#ifdef TRACE
    Serial.println(F("QF_onStartup"));
#endif

    // set Timer2 in CTC mode, 1/1024 prescaler, start the timer ticking...
    TCCR2A = (1U << WGM21) | (0U << WGM20);
    TCCR2B = (1U << CS22 ) | (1U << CS21) | (1U << CS20); // 1/2^10
    ASSR  &= ~(1U << AS2);
    TIMSK2 = (1U << OCIE2A); // enable TIMER2 compare Interrupt
    TCNT2  = 0U;

    // set the output-compare register based on the desired tick frequency
    OCR2A  = (F_CPU / BSP_TICKS_PER_SEC / 1024U) - 1U;
}

//............................................................................
void QV_onIdle(void) {   // called with interrupts DISABLED

#ifdef TRACE
    Serial.println(F("QV_onIdle"));
#endif

    Serial.flush();
    // Put the CPU and peripherals to the low-power mode. You might
    // need to customize the clock management for your application,
    // see the datasheet for your particular AVR MCU.
    set_sleep_mode(SLEEP_MODE_PWR_DOWN);

    // Shutdown all peripherals but watchdog.
    // It will shut down statemachine heartbeat until
    // watchdog it
    PRR = 0b11101111;

    sleep_enable();

    //QV_CPU_SLEEP();  // atomically go to sleep and enable interrupts
    sei();
    sleep_mode();
    sleep_disable();

    // let TWI, SPI and TIMER0 off and wakeup others
    PRR = 0b10010100;

    // also shutdown usart
    // PRR = 0b10010110;
}

//............................................................................
void Q_onAssert(char const Q_ROM * const file, int line) {

#ifdef TRACE
    // implement the error-handling policy for your application!!!
    Serial.print(F("Assertion raised in '"));
    Serial.print(file);
    Serial.print(F("' at line"));
    Serial.print(line);
#endif
    QF_INT_DISABLE(); // disable all interrupts
    QF_RESET();  // reset the CPU
}
