<?xml version="1.0" encoding="UTF-8"?>
<model version="4.6.0" links="0">
 <framework name="qpn"/>
 <package name="AOs" stereotype="0x02">
  <class name="Sensor" superclass="qpn::QActive">
   <statechart properties="0x01">
    <initial target="../1">
     <initial_glyph conn="46,7,4,0,5">
      <action box="0,-2,10,2"/>
     </initial_glyph>
    </initial>
    <state name="Active">
     <entry>#ifdef TRACE
  Serial.println(&quot;Enter Active&quot;);
#endif
</entry>
     <exit>#ifdef TRACE
    Serial.println(&quot;Exit Active&quot;);
#endif</exit>
     <initial target="../2/1">
      <initial_glyph conn="37,16,5,0,28,8">
       <action box="0,-2,10,2"/>
      </initial_glyph>
     </initial>
     <state name="Idle">
      <entry>#ifdef TRACE
  Serial.println(&quot;Enter Idle&quot;);
  tinySensor.PowerDown();
#endif</entry>
      <exit>#ifdef TRACE
  Serial.println(&quot;Exit Idle&quot;);
  tinySensor.PowerUp();
#endif</exit>
      <tran trig="SENSE" target="../../2/1">
       <tran_glyph conn="36,30,1,3,20">
        <action box="1,-3,10,2"/>
       </tran_glyph>
      </tran>
      <state_glyph node="18,26,18,12">
       <entry box="1,2,6,2"/>
       <exit box="1,4,4,2"/>
      </state_glyph>
     </state>
     <state name="Powered">
      <entry>#ifdef TRACE
    Serial.println(F(&quot;Enter Powered&quot;));
#endif</entry>
      <exit>#ifdef TRACE
    Serial.println(F(&quot;Exit Powered&quot;));
#endif

</exit>
      <state name="Sending">
       <entry brief="Transmit all sensors information">#ifdef TRACE
    Serial.println(F(&quot;Enter Sending&quot;));
#endif

tinySensor.SendTemperature();
tinySensor.SendBatteryLevel();

QACTIVE_POST(&amp;me-&gt;super, EMISSION_FINISHED_SIG, me-&gt;super.prio);</entry>
       <exit>#ifdef TRACE
    Serial.println(F(&quot;Exit Sending&quot;));

#endif</exit>
       <tran trig="EMISSION_FINISHED" target="../../../1">
        <tran_glyph conn="70,49,3,2,-49,-11">
         <action box="-18,1,16,2"/>
        </tran_glyph>
       </tran>
       <state_glyph node="70,43,30,11">
        <entry box="1,2,26,3"/>
        <exit box="1,5,6,2"/>
       </state_glyph>
      </state>
      <state name="Sensing">
       <entry brief="Sense and save">#ifdef TRACE
  Serial.println(F(&quot;Enter Sensing&quot;));
#endif

tinySensor.ReadTemperature();
tinySensor.ReadVcc();

QACTIVE_POST(&amp;me-&gt;super, SEND_SIG, me-&gt;super.prio);</entry>
       <exit>#ifdef TRACE
    Serial.println(F(&quot;Exit Sensing&quot;));
#endif
</exit>
       <tran trig="SEND" target="../../0">
        <tran_glyph conn="68,33,2,0,6,18,4">
         <action box="1,2,12,2"/>
        </tran_glyph>
       </tran>
       <state_glyph node="56,24,27,9">
        <entry box="1,2,23,2"/>
        <exit box="1,4,6,2"/>
       </state_glyph>
      </state>
      <state_glyph node="46,20,61,37">
       <entry box="1,2,6,2"/>
       <exit box="1,4,6,2"/>
      </state_glyph>
     </state>
     <state_glyph node="14,12,100,48">
      <entry box="1,2,22,2"/>
      <exit box="1,4,22,8"/>
     </state_glyph>
    </state>
    <state_diagram size="147,82"/>
   </statechart>
  </class>
 </package>
 <directory name=".">
  <file name="sensor.ino" codec="UTF-8">
   <text>
#include &lt;avr/sleep.h&gt;
#include &lt;avr/wdt.h&gt;
#include &lt;TinySensor.h&gt;
#include &lt;LowPower.h&gt;

TinySensor tinySensor;


Q_DEFINE_THIS_MODULE(&quot;sensor&quot;)

//============================================================================
enum SensorSignals
{
    SEND_SIG = Q_USER_SIG,
    EMISSION_FINISHED_SIG,
    SENSE_SIG,
};


$declare(AOs::Sensor)
$define(AOs::Sensor)

Sensor AO_Sensor;

//...................Interrupt handlers......................................

volatile uint8_t _sleepDelayCounter = SLEEP_DELAY_SECOND;

ISR(WDT_vect)
{
    wdt_disable();
    if (_sleepDelayCounter == 0)
    {
        _sleepDelayCounter = SLEEP_DELAY_SECOND;
        QACTIVE_POST_ISR((QMActive *)&amp;AO_Sensor, SENSE_SIG, 0U);
    }
    else
    {
        --_sleepDelayCounter;
    }
}

#if defined(__AVR_ATmega32U4__)
ISR(TIMER3_COMPA_vect)
#elif defined(__AVR_ATmega328P__)
ISR(TIMER2_COMPA_vect)
#endif 
{
    QF_tickXISR(0);
}

//............................................................................


// QF_active[] array defines all active object control blocks ----------------
static QEvt l_sensorQSto[10]; // Event queue storage for Sensor

QActiveCB const Q_ROM QF_active[] = {
    {(QActive *)0, (QEvt *)0, 0U},
    {(QActive *)&amp;AO_Sensor, l_sensorQSto, Q_DIM(l_sensorQSto)}};


//............................................................................
void setup()
{
    wdt_disable();

    // initialize the QF-nano framework
    QF_init(Q_DIM(QF_active));
    QActive_ctor(&amp;AO_Sensor.super, Q_STATE_CAST(&amp;Sensor_initial));

    tinySensor.Setup();
}

//
void loop()
{
    QF_run(); // run the QP-nano application
}

//============================================================================

// QF callbacks...
void QF_onStartup(void)
{

#ifdef TRACE
    Serial.println(F(&quot;QF_onStartup&quot;));
#endif

    tinySensor.SetupHeatbeat();
}

//............................................................................
void QV_onIdle(void)
{ 

    // called with interrupts DISABLED

    tinySensor.BeforeIdle();
    set_sleep_mode(SLEEP_MODE_PWR_DOWN);
    sei();
    sleep_cpu ();
    sleep_disable();
}

//............................................................................
void Q_onAssert(char const Q_ROM *const file, int line)
{

#ifdef TRACE
    // implement the error-handling policy for your application!!!
    Serial.print(F(&quot;Assertion:&quot;));
    Serial.print(file);
    Serial.print(F(&quot;' at line&quot;));
    Serial.print(line, DEC);

    for (uint32_t volatile i = 100000; i &gt; 0; --i) {
    }

#endif
    QF_INT_DISABLE(); // disable all interrupts
    QF_RESET();       // reset the CPU

}</text>
  </file>
 </directory>
</model>
